{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Wondering why I built Forge?</p> <p>Forge currently exposes running GitHub Actions (e.g. <code>actions/setup-go</code>), Concourse resources (e.g. <code>concourse/git-resource</code>) and Google Cloudbuild steps (e.g. <code>gcr.io/cloud-builders/docker</code>) and more in its Go module.</p> <p>Interested in helping develop Forge?</p>"},{"location":"concourse/","title":"Execute Concourse resources","text":"<p>Forge can be used to run, test and debug Concourse resources (e.g. <code>concourse/git-resource</code>) or to utilize them within other CI systems.</p> <p>Forge is specifically focused on running individual Concourse resources (e.g. <code>concourse/git-resource</code>), not entire Concourse pipelines. For example, Forge is not intended to run a pipeline such as:</p> <pre><code># pipeline.yml\nresources:\n  - name: forge-git\n    type: git\n    source:\n      uri: https://github.com/frantjc/forge\njobs:\n  - name: example\n    plan:\n      - get: forge-git\n        trigger: true\n</code></pre> <p>Rather, it is intended to run a single resource from within a pipeline, like so:</p> <pre><code>forge get forge-git --config pipeline.yml\n</code></pre> <p>Forge mounts the current working directory to the resource's. So, after the previous command is ran, if it succeeds, the working directory should have <code>frantjc/forge</code> cloned into it.</p> <p>Forge can also execute a Concourse resource's <code>check</code> and <code>put</code> commands by simply replacing the <code>get</code> in the above command, as seen below:</p> <pre><code>forge check forge-git --config pipeline.yml\n</code></pre> <p>When executing Concourse resources, Forge will source <code>resource_types</code> and <code>resources</code> from the working directory's <code>.forge.yml</code> (overridable with <code>--config</code> as seen previously). This schema is conveniently compatible with Concourse's pipeline schema.</p> <p>Just like Concourse itself, Forge ships with some resource types builtin which can also be overridden. This is why the <code>git</code> resource type did not need explicitly defined in the above examples.</p> <p>You can also attach to the container executing the resource to snoop around:</p> <pre><code>forge get --attach forge-git\n</code></pre> <p>The resource's image must have <code>bash</code> or <code>sh</code> on its <code>PATH</code> for the attach to work.</p>"},{"location":"developing/","title":"Developing Forge","text":"<ul> <li><code>git</code> is required</li> <li><code>make</code> is required</li> <li><code>go</code> 1.20 is required for multi-error handling</li> <li><code>docker</code> is required to test as it is its only runtime</li> <li><code>upx</code> is required for compressing <code>shim</code></li> <li><code>node</code> 20 is required for developing the <code>action</code></li> </ul>"},{"location":"github-actions/","title":"Use GitHub Actions","text":"<p>Forge can be used to run, test and debug GitHub Actions (e.g. <code>actions/setup-go</code>) or to utilize them within other CI systems.</p> <p> </p> <p>Forge is specifically focused on running individual GitHub Actions (e.g. <code>actions/checkout</code>), not entire GitHub Actions' workflows. For example, Forge is not intended to run a workflow such as:</p> <pre><code>on: push\njobs:\n  example:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-go@v5\n        with:\n          go-version: 1.22\n</code></pre> <p>Rather, it is intended to run an Action from within a workflow, like so:</p> <pre><code>forge use actions/setup-go@v5 --with go-version=1.22\n</code></pre> <p>When running an Action, Forge mounts the current working directory to the Action's <code>GITHUB_WORKSPACE</code> as well as directories respecting the XDG Base Directory Specification to the Action's <code>RUNNER_TOOLCACHE</code> and <code>RUNNER_TEMP</code>. So, after the above command is ran, if it succeeds, <code>go</code> should be installed somewhere in <code>XDG_CACHE_HOME/forge/runner/toolcache</code>. This can be found more easily by running:</p> <pre><code>forge cache toolcache\n</code></pre> <p>Some Actions rely heavily on some default variables provided by GitHub. For example, <code>actions/checkout</code> requires on the environment variable <code>GITHUB_REPOSITORY</code> to be set to know which repository it should checkout.</p> <p>Forge does its best to source such variables from the working directory's Git configuration as well as GitHub's default environment variables in its own environment.</p> <p>However, in the event that an action errors and reports that a variable that it relies on is not set, it's likely that Forge did not find a value for that variable. For example, <code>actions/checkout</code> errors and reports by saying: <code>\"[error] context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'\"</code>.</p> <p>In such cases, you can provide the value as an environment variable:</p> <pre><code>GITHUB_REPOSITORY=frantjc/forge forge use actions/checkout@v4\n</code></pre> <p>Authentication to GitHub is provided to Forge in a similar way--through the <code>GITHUB_TOKEN</code> environment variable. The value for the environment variable should be a personal access token and can be injected into the environment more safely via something like <code>~/.bash_profile</code> like so:</p> <pre><code>export GITHUB_TOKEN=yourtokenhere\n</code></pre> <p>Forge can also execute local GitHub Actions. This helps custom action developers more quickly and easily test out their actions while developing them locally.</p> <p>To signify to Forge that a GitHub Action can be found on the filesystem as opposed to in a GitHub repository, start the reference with <code>\"/\"</code> or <code>\".\"</code> for absolute or relative filepaths, respectively. For example:</p> <pre><code>forge use ./testdata/actions/docker\n</code></pre> <p>Local Actions cannot refer to files outside of the <code>action.yml</code>'s directory.</p> <p>For additional assistance with debugging, you can attach to the container running the Action to snoop around:</p> <pre><code>forge use --attach ./testdata/actions/dockerfile\n</code></pre> <p>If the Action runs using a custom image, that image must have <code>bash</code> or <code>sh</code> on its <code>PATH</code> for the attach to work.</p>"},{"location":"google-cloudbuild/","title":"Run Google CloudBuild steps","text":"<p>Forge can be used to run, test and debug <code>Google CloudBuild steps</code> (e.g. <code>gcr.io/cloud-builders/docker</code>).</p> <p>Forge is specifically focused on running individual CloudBuild steps (e.g. <code>gcr.io/cloud-builders/docker</code>), not entire build config files. For example, Forge is not intended to run a build config file such as:</p> <pre><code>steps:\n  - name: gcr.io/cloud-builders/docker\n    args:\n      - build\n      - -t\n      - 'us-central1-docker.pkg.dev/${PROJECT_ID}/my-docker-repo/my-image'\n      - .\n</code></pre> <p>Rather, it is intended to run an individual step from within a build config file, like so:</p> <pre><code>forge cloudbuild forge-git gcr.io/cloud-builders/docker -- build -t 'us-central1-docker.pkg.dev/${PROJECT_ID}/my-docker-repo/my-image' .\n</code></pre> <p>In the previous example, the <code>--</code> is important to signify to Forge that the rest of the arguments are meant to be passed to the underlying step, not parsed by Forge itself. Additionally, the <code>''</code> are important to keep your shell from doing the substitution before Forge can get ahold of it.</p> <p>Forge mounts the current working directory to the step's as well as a directory respecting the XDG Base Directory Specification to the step's <code>/workspace</code>.</p> <p>Forge will try to source the default substitutions (e.g. for <code>PROJECT_ID</code> above) from the working directory's Git configuration as well as <code>~/.config/gcloud</code>.</p> <p>Forge can modify the entrypoint to a Google CloudBuild step as well, like so:</p> <pre><code>forge cloudbuild --entrypoint bash gcr.io/cloud-builders/docker -- -c \"docker build -t 'us-central1-docker.pkg.dev/${PROJECT_ID}/my-docker-repo/my-image' .\"\n</code></pre> <p>In the previous example, <code>\"\"</code> are important to pass the entire <code>docker</code> command as the value to <code>bash</code>'s <code>-c</code> flag.</p> <p>For additional debugging, you can attach to the container running the step to snoop around:</p> <pre><code>forge cloudbuild --attach gcr.io/cloud-builders/docker -- build -t 'us-central1-docker.pkg.dev/${PROJECT_ID}/my-docker-repo/my-image' .\n</code></pre> <p>The step's image must have <code>bash</code> or <code>sh</code> on its <code>PATH</code> for the attach to work.</p>"},{"location":"install/","title":"Install","text":"<p>From a release.</p> <p>Using <code>brew</code>:</p> <pre><code>brew install frantjc/tap/forge\n</code></pre> <p>From source:</p> <pre><code>git clone https://github.com/frantjc/forge\ncd forge\nmake\n</code></pre> <p>Using <code>go</code>:</p> <pre><code>go install github.com/frantjc/forge/cmd/forge\n</code></pre> <p>In GitHub Actions:</p> <pre><code>- uses: frantjc/forge@v0\n</code></pre> <p>As a library:</p> <pre><code>go get -u github.com/frantjc/forge\n</code></pre>"},{"location":"library/","title":"Import as a Go module","text":"<p>Forge can be used as a library as well. Each type of step from a proprietary CI system is represented as an <code>Ore</code> and live in the package <code>ore</code>. For example: a GitHub <code>Action</code>.</p> <p>There are a few additional helper <code>Ore</code>s: <code>Lava</code>, which pipes the stdout of one or to the stdin of another; <code>Alloy</code>, which runs other sequential Ores that will share a working directory; and <code>Pure</code>, which simply runs one containerized command.</p> <p>In this example, a <code>Lava</code> is used to pipe the stdout of a GitHub Action, which is using <code>actions/checkout</code> to check out https://github.com/frantjc/forge, to a <code>Pure</code> running <code>grep</code>, only printing lines that contain the string <code>\"debug\"</code>:</p> <pre><code>import (\n    // Some std imports omitted for brevity.\n\n    \"github.com/docker/docker/client\"\n    \"github.com/frantjc/forge\"\n    \"github.com/frantjc/forge/githubactions\"\n    \"github.com/frantjc/forge/ore\"\n    \"github.com/frantjc/forge/runtime/docker\"\n)\n\nfunc main() {\n    cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n\n    globalContext := githubactions.NewGlobalContextFromEnv().EnableDebug()\n    globalContext.GitHubContext.Repository = \"frantjc/forge\"\n\n    // Checkout https://github.com/frantjc/forge\n    // using https://github.com/actions/checkout,\n    // grepping to only print debug logs.\n    if err = forge.NewFoundry(docker.New(cli)).Process(\n        ctx,\n        &amp;ore.Lava{\n            From: &amp;ore.Action{\n                Uses:          \"actions/checkout@v4\",\n                GlobalContext: globalContext,\n            },\n            To: &amp;ore.Pure{\n                Image:      \"alpine:3.19\",\n                Entrypoint: []string{\"grep\", \"debug\"},\n            },\n        },\n        forge.StdDrains(),\n    ); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n</code></pre>"},{"location":"motivation/","title":"Why?","text":"<p>What problem does this solve? Well...</p> <p>Automation begins with a shell script that executes a bunch of CLI commands often to test, build and publish some code. The next step is to set up some continuous integration (CI) system that executes that script in response to some event such as a commit to a Git repository's <code>main</code> branch. Such CI systems tend to identify that all of the scripts that they are executing do a lot of the same things--checkout a Git repository, setup a tool and so on.</p> <p>In an effort to make their platform easier to use and to refactor the shared functionality out of all of the aforementioned scripts, CI systems in the past have introduced reusable \"Actions\"/\"CloudBuilders\"/\"resources\"/\"tasks\" which take minimal configuration to do a complex task. GitHub Actions' <code>actions/checkout</code>, for example, takes one short line of code to invoke and accepts a bunch of optional configuration to fulfill many related use cases.</p> <p>Unfortunately, using such powerful plugins outside of the the system they were built for can be wildly difficult. This makes debugging the use of these plugins require long feedback loops. It also makes migrating from one CI system to another treacherous, having to replace uses of one system's plugins with another's.</p> <p>Forge aims to remedy this.</p>"}]}